var rpt = require('read-package-tree');
var rimraf = require('rimraf');
var mkdirp = require('mkdirp');
var resolveModule = require('resolve');
var pkgDir = require('pkg-dir');
var async = require('async');
var fs = require('fs');
var path = require('path');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var debuglog = util.debuglog('tsdm');

// todo: proxy npm commands for auto rewire?
// todo: .tsdmrc for tsdm configuration?
// fixme: if scoped-typings were removed - corresponding node_module
// will still contain invalid reference

/**
 * @param path {string}
 * @param filter {function} (pkg)
 * @param cb {function} (err, array of packages)
 */
function list(path, filter, cb) {
  var rootNode;
  rpt(path, function (node) {
    return (rootNode || (rootNode = node)) === node;
  }, function (err, data) {
    if (err) {
      return cb(err);
    }
    var defModules = data.children
      .reduce(function (r, node) {
        var pkg = node.package;
        if (filter(pkg)) {
          // _id: '<name>@<version>'
          pkg._where = node.realpath;
          r.push(pkg);
        }
        return r;
      }, [])
      .sort(function (l, r) { return l.name.localeCompare(r.name); });
    cb(null, defModules);
  });
}

/**
 * @param dir {string}
 * @param filter {function} (stats, path)
 * @param cb {function} (err)
 */
function rm(dir, filter, cb) {
  fs.readdir(dir, function (err, fileNames) {
    if (err) {
      return cb(err);
    }
    async.each(fileNames, function (fileName, cb) {
      var file = path.join(dir, fileName);
      fs.lstat(file, function (err, stats) {
        if (err) {
          return cb(err);
        }
        if (filter(stats, file)) {
          fs.unlink(file, cb);
        } else {
          cb();
        }
      });
    }, cb);
  });
}

/**
 * @param src {string|array}
 * @param dst {string}
 * @param cb {function} (err)
 */
function link(src, dst, cb) {
  Array.isArray(src) || (src = [src]);
  async.each(src, function (src, cb) {
    var link = path.join(dst, path.basename(src));
    fs.symlink(src, link, cb);
  }, cb);
}

/**
 * @param file {string}
 * @param refs {array}
 * @param cb {function} (err)
 */
function commit(file, refs, cb) {
  var data = [
    '// Autogenerated, do not edit. All changes will be overwritten.\n'
  ].concat(
    refs.map(function (ref) {
      return '/// <reference path="' + ref + '" />';
    })
  ).join('\n');
  fs.writeFile(file, data, function (err) {
    if (err) {
      return cb(err);
    }
    cb();
  });
}

function rewireAmbientTypings(o, ee, cb) {
  list(o.path,
    function (pkg) { return pkg.typescript && pkg.typescript.definition; },
    function (err, pkgs) {
      if (err) {
        return cb(err);
      }
      var defRoot = path.join(o.path, 'typings');
      if (!pkgs.length) {
        return rimraf(defRoot, cb);
      }
      pkgs.forEach(function (pkg) {
        debuglog('Found ambient typings provider : ' +
          path.relative(process.cwd(), pkg._where));
      });
      // create typings/ directory
      mkdirp(defRoot, function (err) {
        if (err) {
          return cb(err);
        }
        // delete previous symlinks
        rm(defRoot,
          function (stats) {
            return stats.isSymbolicLink();
          },
          function (err) {
            if (err) {
              return cb(err);
            }
            // re-symlink

            // N.B. strictly speaking symlinks are unnecessary, but some
            // tools (WebStorm 11 to be more specific) do not ignore
            // definitions under node_modules/

            link(pkgs.map(function (pkg) { return pkg._where; }), defRoot,
              function (err) {
                if (err) {
                  return cb(err);
                }
                pkgs.forEach(function (pkg) {
                  ee.emit('wired', {type: 'ambient', pkg: pkg});
                });
                var refs = pkgs.reduce(function (r, pkg) {
                  var def = [].concat(pkg.typescript.definition);
                  return r.concat(def.map(function (def) {
                    return path.join(pkg.name, def);
                  }));
                }, []);
                var override = path.join(o.path, '.tsdm.d.ts');
                fs.stat(override, function (err, stats) {
                  if (!err && stats.isFile()) {
                    refs.push(path.relative(defRoot, override));
                  }
                  // re-generate typings/tsd.d.ts
                  commit(path.join(defRoot, 'tsd.d.ts'), refs, cb);
                });
              });
          });
      });
    });
}

function rewireScopedTypings(o, ee, cb) {
  list(o.path,
    function (pkg) { return pkg.typings && pkg.typingsScope; },
    function (err, pkgs) {
      if (err) {
        return cb(err);
      }
      pkgs.forEach(function (pkg) {
        debuglog('Found typings provider : ' +
          path.relative(process.cwd(), pkg._where));
      });
      // resolve external type declarations
      async.map(pkgs, function (pkg, cb) {
        resolveModule(pkg.typingsScope, {basedir: pkg._where},
          function (err, location) {
            if (err) {
              return cb(err);
            }
            pkgDir(location)
              .then(function (dir) {
                var base = path.relative(dir, pkg._where);
                cb(null, {
                  source: path.join(pkg._where, 'package.json'),
                  path: dir,
                  typings: [].concat(pkg.typings).map(function (t) {
                    return path.join(base, t);
                  })
                });
              })
              .catch(cb);
          });
      }, function (err, uu) {
        if (err) {
          return cb(err);
        }
        // update packages with external type declarations
        async.each(uu, function (u, cb) {
          var file = path.join(u.path, 'package.json');
          fs.readFile(file, function (err, data) {
            if (err) {
              return cb(err);
            }
            var json;
            try {
              json = JSON.parse(data);
            } catch (e) {
              return cb(new Error('Failed to parse ' + file +
                ' (not a valid JSON)'));
            }
            json._tsdm || (json._tsdm = json.typings || true);
            if (u.typings.length > 1) {
              ee.emit('warn', u.source + ' contains multiple typings. ' +
                'Only the first one will be wired in');
            }
            json.typings = u.typings[0];
            fs.writeFile(file, JSON.stringify(json, null, 2),
              function (err) {
                if (err) {
                  return cb(err);
                }
                ee.emit('wired', {type: 'scoped', file: file});
                cb();
              });
          });
        }, cb);
      });
    });
}

module.exports = {
  rewire: function (o) {
    var ee = new EventEmitter();
    process.nextTick(function () {
      async.parallel([
        rewireAmbientTypings.bind(null, o, ee),
        rewireScopedTypings.bind(null, o, ee)
      ], function (err) {
        err && ee.emit('error', err);
        ee.emit('end');
      });
    });
    return ee;
  }
};
